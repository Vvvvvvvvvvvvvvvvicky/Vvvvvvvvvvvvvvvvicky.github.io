<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vic</title>
  
  <subtitle>日常打卡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://vvvvvvvvvvvvvvvvicky.github.io/"/>
  <updated>2020-04-04T17:12:49.486Z</updated>
  <id>https://vvvvvvvvvvvvvvvvicky.github.io/</id>
  
  <author>
    <name>Vic Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用redmine进行项目管理</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2020/04/04/%E4%BD%BF%E7%94%A8redmine%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2020/04/04/使用redmine进行项目管理/</id>
    <published>2020-04-04T14:15:42.000Z</published>
    <updated>2020-04-04T17:12:49.486Z</updated>
    
    <content type="html"><![CDATA[<p>使用redmine用来管理项目进度的过程记录。</p><p>（有空建议打一个tfs，看起来更舒服）</p><a id="more"></a><p>起源：公司项目管理方式不统一，日常工作都是使用excel表格追溯，不利于回顾。项目管理软件又迟迟审批不下来，所以各项目目前自发使用redmine来进行项目管理。</p><p>角色：<strong><u>需求</u></strong>、测试、开发、<strong><u>月度版本管理</u></strong>、<u><strong>代码版本管理</strong></u></p><p>项目使用路线图进行版本管理：</p><p>项目-配置-版本-新建版本</p><p><img src="/2020/04/04/使用redmine进行项目管理/新建版本路线图.jpg" alt="新建版本路线图"></p><p>1.系统分析师接到需求后，<strong><u>新建需求</u></strong>，并<strong><u>将需求拆分新建多个任务</u></strong>（状态为新建），并指派给对应开发（可以为多个）。</p><p>（1）登记基本信息，上传需求文档</p><p>（2）评估工时（以最小时间2h计，倍数递增），登记版本</p><p>（3）拆分任务：按功能点/交易模块，拆分任务，并指派，同时需要评估模块开发时间（以最小时间2h计，倍数递增）</p><p>2.开发人员接到<strong><u>任务</u></strong>后，开始开发工作（状态为进行中），更新进度，<strong><u>开发完成后将任务指派给测试人员</u></strong></p><p>3.测试人员开始测试工作，该功能点有缺陷时，<strong><u>新建缺陷</u></strong>并指派给开发人员处理（状态为新建）</p><p>4.开发人员修复缺陷后，指回给对应测试人员，状态置为<strong><u>已解决</u></strong></p><p>5.测试人员验证缺陷修复情况，并<strong><u>关闭缺陷</u></strong></p><p>6.测试人员任务验证通过后，将<u><strong>任务关闭</strong></u></p><p>7.全部任务关闭后，需求人员<u><strong>关闭需求</strong></u>，并通知开发人员<strong><u>准备代码清单</u></strong>。（目前在svn，后期考虑redmine，或者转为git后使用tag）</p><p>8.版本人员投产前（时间建议提早、预留准生产复测时间），统计版本清单，登记wiki。</p><p><img src="/2020/04/04/使用redmine进行项目管理/版本wiki.jpg" alt="版本wiki"></p><p>9.代码版本管理员接到清单后，合并代码，部署准生产给测试人员复测。</p><p>10.测试通过，代码版本管理员合并投产代码，通知测试中心打包，并在投产演练环境验证投产包及脚本。</p><p>11.测试中心验证通过，根据<strong><u>版本wiki</u></strong>，将放至待投产仓库内。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用redmine用来管理项目进度的过程记录。&lt;/p&gt;
&lt;p&gt;（有空建议打一个tfs，看起来更舒服）&lt;/p&gt;
    
    </summary>
    
      <category term="管理" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="redmine" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/redmine/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2020/03/29/hexo%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2020/03/29/hexo插件使用/</id>
    <published>2020-03-29T12:17:16.000Z</published>
    <updated>2020-03-29T12:42:31.292Z</updated>
    
    <content type="html"><![CDATA[<p>记录了我使用到hexo的一些问题（从3月29日起）。</p><p>前面使用到的后续再补充上来。</p><a id="more"></a><ul><li><a href="#1markdown---toc-------github---">1.markdown的原生TOC生成目录方式对github不支持</a></li><li><a href="#2--hexo--">2.常用hexo命令</a></li></ul><h2 id="1-markdown的原生TOC生成目录方式对github不支持"><a href="#1-markdown的原生TOC生成目录方式对github不支持" class="headerlink" title="1.markdown的原生TOC生成目录方式对github不支持"></a>1.markdown的原生TOC生成目录方式对github不支持</h2><p>在线生成工具 <a href="https://ecotrust-canada.github.io/markdown-toc/" target="_blank" rel="noopener">markdown-toc</a></p><h2 id="2-常用hexo命令"><a href="#2-常用hexo命令" class="headerlink" title="2.常用hexo命令"></a>2.常用hexo命令</h2><p>hexo clean 清空缓存文件</p><p>hexo generate （或hexo g）</p><p>hexo deploy（或hexo d）d</p><p>hexo server （或hexo s）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录了我使用到hexo的一些问题（从3月29日起）。&lt;/p&gt;
&lt;p&gt;前面使用到的后续再补充上来。&lt;/p&gt;
    
    </summary>
    
      <category term="学习记录" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="hexo" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>maven一知半解</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2020/03/29/maven%E4%B8%80%E7%9F%A5%E5%8D%8A%E8%A7%A3/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2020/03/29/maven一知半解/</id>
    <published>2020-03-29T11:07:53.000Z</published>
    <updated>2020-03-29T13:22:49.072Z</updated>
    
    <content type="html"><![CDATA[<p>maven操作的各种问题记录</p><a id="more"></a><ul><li><a href="#1-mvn-clean-install---mvn-clean---">1.mvn clean install 和 mvn clean 区别</a></li><li><a href="#2-mvn-clean-package--x----------debug--">2.mvn clean package -X 就能看到非常丰富的DEBUG信息</a></li></ul><h2 id="1-mvn-clean-install-和-mvn-clean-区别"><a href="#1-mvn-clean-install-和-mvn-clean-区别" class="headerlink" title="1.mvn clean install 和 mvn clean 区别"></a>1.mvn clean install 和 mvn clean 区别</h2><p>现象发生的场景：mvn install后，新改的内容不生效，一定要后来使用mvn clean install 才生效。</p><p>mvn install ：compile -&gt; package -&gt; test</p><p>org.codehaus.plexus.archiver.AbstractArchiver中的关键一段，用来判断是否强制新建jar<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkForced</span><span class="params">()</span> <span class="keyword">throws</span> ArchiverException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !isForced() &amp;&amp; isSupportingForced() &amp;&amp; isUptodate() )</span><br><span class="line">    &#123;</span><br><span class="line">        getLogger().debug( <span class="string">"Archive "</span> + getDestFile() + <span class="string">" is uptodate."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码中提到有这么几个情况，会认为jar包不是最新的：</p><ol><li>jar包不存在（其实就是mvn clean的效果）</li><li>传入比较的文件资源不存在</li><li>Resource with unknown modification date found，资源的修改时间未知</li><li>Resource with newer modification date found，jar包的最后修改时间比资源的最后修改时间早</li></ol><p>总结：</p><ol><li>mvn clean 得到的jar包是最新的，除非其他方式修改jar包中的内容而不修改源代码。</li><li>日常可以用mvn install，不进行chean，以节省时间；但最保险还是用 mvn clean install 生成最新的jar包或其他包</li><li>不想用mvn clean又想保证jar包最新，建议添加 -Djar.forceCreation 参数</li></ol><h2 id="2-mvn-clean-package-X-就能看到非常丰富的DEBUG信息"><a href="#2-mvn-clean-package-X-就能看到非常丰富的DEBUG信息" class="headerlink" title="2.mvn clean package -X 就能看到非常丰富的DEBUG信息"></a>2.mvn clean package -X 就能看到非常丰富的DEBUG信息</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;maven操作的各种问题记录&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="maven" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>《算法》读书笔记</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2020/01/31/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2020/01/31/《算法》读书笔记/</id>
    <published>2020-01-31T03:26:42.000Z</published>
    <updated>2020-02-01T08:35:37.661Z</updated>
    
    <content type="html"><![CDATA[<p>《算法图解》的读书笔记。<br><a id="more"></a></p><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>大O表示法是指算法运行有多快，指出了算法运行时间的增速。用大O表示法表示算法运行时间。</p><p>常见的大O时间：<br>0.O(1)：常量时间<br>1.O(log n)：对数时间，二分查找<br>2.O(n)：线性时间，简单查找<br>3.O(n * log n)：快速排序（平均，最差情况为O(n^2)），合并排序（总是）（常用快速，而非合并，因为快速查找使用时间较短）<br>4.O(n^2)：选择排序<br>5.O(n!)：旅行商问题</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数组：读取速度快<br>链表：插入、删除速度快<br>栈：后入先出。所有函数调用都进入调用栈（调用栈过长会占用大量内存）<br>队列：先进先出<br>散列表：key-value</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>仅当列表有序时，才管用。</p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>遍历列表，选择最大的值，添加进新的列表中。对余下的数组循环这个过程，直到全部排完。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>需要有基线条件和递归条件<br><img src="/2020/01/31/《算法》读书笔记/递归简化流程.jpg" alt="递归简化流程" style="zoom:40%;"></p><h4 id="分而治之（D-amp-C-divide-and-conquer）"><a href="#分而治之（D-amp-C-divide-and-conquer）" class="headerlink" title="分而治之（D&amp;C: divide and conquer）"></a>分而治之（D&amp;C: divide and conquer）</h4><p>1.找出基线条件<br>2.不断将问题分解（缩小规模），直到符合基线条件</p><h4 id="归纳证明"><a href="#归纳证明" class="headerlink" title="归纳证明"></a>归纳证明</h4><p>分为基线条件和归纳条件。<br>例：在基线条件中，证明算法对空数组或包含一个元素的数组有效；在归纳条件中，算法对一个元素的数组有效、对含两个元素的数组也有效（对含k个元素的数组管用，并对k+1个元素的数组也管用），那么可以推断出对任何元素的数组都管用。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序就使用D&amp;C策略。<br>步骤：<br>1.随机选择基准值；<br>2.将数组分成两个子数组：小于基准值的和大于基准值的。<br>3.对这两个子数组进行快速排序。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列函数要求：<br>1.散列函数必须是一致的。<br>2.不同输入映射不同输出结果。</p><p>散列函数特点：<br>1.散列函数总是将同样的输入映射到相同索引。<br>2.散列函数总是将不同的输入映射到不同的索引。<br>3.散列函数记录数组的大小，只返回有效索引。</p><p>用途：<br>1.用于快速查找，O(1)。<br>2.防止重复。<br>3.用于缓存。</p><p>优化冲突（两个不同键对于同个位置（需要使用链表存储，极端情况影响性能））：<br>1.较低的装填因子；<br>    装填因子=散列表包含的元素数/位置总数<br>    装填因子越低，发生冲突的可能性越小，散列表性能越高。<br>    常见规则：装填因子大于0.7，需要调整散列表长度。<br>2.良好的散列函数。<br>    避免“扎堆”<br>    例：SHA函数</p><h3 id="广度优先搜索（图算法，breadth-first-search-BFS）——非加权图"><a href="#广度优先搜索（图算法，breadth-first-search-BFS）——非加权图" class="headerlink" title="广度优先搜索（图算法，breadth-first search,BFS）——非加权图"></a>广度优先搜索（图算法，breadth-first search,BFS）——非加权图</h3><p>可以解决如下问题：<br>1.从节点A出发，是否有到节点B的路径<br>2.从节点A出发，是否有到节点B的最短路径</p><p>使用图建立模型，使用队列实现<br>检查过的人不需要再次检查，否则可能导致无限循环。</p><h3 id="狄克斯特拉算法——加权图"><a href="#狄克斯特拉算法——加权图" class="headerlink" title="狄克斯特拉算法——加权图"></a>狄克斯特拉算法——加权图</h3><p>找最快的路径，仅可用于有向无环加权图，不可用于包含父权边的图。<br>算法步骤：<br>1.找出“最便宜”的节点，即可在最短时间内达到的节点<br>2.更新该节点的邻居节点的开销<br>3.重复该过程，直到全部节点都执行完。</p><p>有向图中，包含父权边——使用贝尔曼-福德算法</p><h3 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h3><p>“每步都选择局部最优解”<br>易于实现、运行速度较快，是不错的近似算法。</p><h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><p>使用贪婪策略，可以获得近似解，但获取不到最优解：<br>1.装入可装入的最贵的商品<br>2.再装入可以装入的最贵的商品，依次类推。</p><h3 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h3><p>旅行商问题、集合覆盖问题<br>特点：需要计算所有的解，并从中选择最小/最短的那个。<br>没有快速解决方案，最佳做法是使用近似算法<br>O(n!)</p><p>哪些是NP完全问题：<br>1.元素较少时，算法运行速度非常快，但随这元素数量增加，速度会变得非常慢。<br>2.涉及“所有组合”的问题。<br>3.不能将问题分成小问题，必须考虑各种可能的情况的问题。<br>4.问题涉及序列（旅行商问题的城市序列）且难以解决。<br>5.问题涉及集合（广播台集合）且难以解决。<br>6.问题可以转换为集合覆盖问题或旅行商问题。</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>算法公式：答案在最后单元格<br>$$<br>cell[i][j]  = 两者中较大的那个：`<br>  \begin{cases}<br>   1.上一个单元格的值（即cell[i-1][j]的值）\<br>   2.当前商品的价格 + 剩余空间的价值（指cell[i-1][j-当前商品的重量]）<br>  \end{cases}<br>$$</p><p>可解决问题：<br>1.背包问题<br>2.旅游行程最优化</p><p>注意：仅当每个子问题都是离散的（不依赖于其他子问题），动态规划才管用。<br>1.可以在给定约束条件下找到最优解<br>2.问题可以分解为彼此独立且离散的子问题时，才可以使用动态规划<br>3.动态规划的解决方案都涉及网格<br>4.单元格的值就是要优化的值<br>5.每个单元格都是一个子问题，设计方案时要考虑如何分解问题</p><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>1.如果两个字母不相同，值为0<br>2.如果两个字母相同，值为左上角邻居加1</p><p>注意：问题最终答案并不在最后一个单元格中，而是网格中的最大数字 </p><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><p>1.如果两个字母不同，就选择上方和左方邻居中较大的那个<br>2.如果两个字母相同，则当前单元格的值为左上方单元格的值加1</p><p>答案在最后单元格</p><h3 id="K最近邻算法"><a href="#K最近邻算法" class="headerlink" title="K最近邻算法"></a>K最近邻算法</h3><p>1.特征抽取<br>2.计算相似度：毕达哥拉斯公式（如下）、余弦相似度（常用）<br>$$<br>    \sqrt (x_1-x_2)^2  + \sqrt  (y_1-y_2)^2<br>$$</p><p>用途：<br>    分类——编组<br>    回归——预测结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《算法图解》的读书笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学习Vue</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2019/11/06/%E5%AD%A6%E4%B9%A0Vue/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2019/11/06/学习Vue/</id>
    <published>2019-11-06T15:29:12.000Z</published>
    <updated>2019-11-06T15:41:53.683Z</updated>
    
    <content type="html"><![CDATA[<p>学习Vue的一些笔记</p><a id="more"></a><h3 id="1-在vue项目中，执行-npm-run-dev-时提示-parser-“babylon”-is-deprecated-we-now-treat-it-as-parser-“babel”"><a href="#1-在vue项目中，执行-npm-run-dev-时提示-parser-“babylon”-is-deprecated-we-now-treat-it-as-parser-“babel”" class="headerlink" title="1.在vue项目中，执行 npm run dev 时提示{ parser: “babylon” } is deprecated; we now treat it as { parser: “babel” }"></a>1.在vue项目中，执行 npm run dev 时提示{ parser: “babylon” } is deprecated; we now treat it as { parser: “babel” }</h3><p>问题原因：是prettier版本导致的，重装prettier：npm install prettier@~1.12.0 -D或者cnpm install prettier@~1.12.0 –save-dev,然后重新npm run dev<br>解决办法：<br>找到modules包里面的：node_modules\vue-loader\lib\template-compiler\index.js<br>将{ parser: “babylon” } 换成  { parser: “babel” } 即可</p><h3 id="2-修改了App-vue后，提示“Component-template-should-contain-exactly-one-root-element-If-you-are-using-v-if-on-multiple-elements-use-v-else-if-to-chain-them-instead-”"><a href="#2-修改了App-vue后，提示“Component-template-should-contain-exactly-one-root-element-If-you-are-using-v-if-on-multiple-elements-use-v-else-if-to-chain-them-instead-”" class="headerlink" title="2.修改了App.vue后，提示“Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.”"></a>2.修改了App.vue后，提示“Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead.”</h3><p>问题原因：<strong>vue模板只能有一个根对象</strong><br>解决方法：用一个div来或是别的标签来包裹全部的元素<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"primary"</span>&gt;</span>button_1<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>div_1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"测试一下"</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123;test1&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Vue的一些笔记&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Vue" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>面试复习笔记</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2019/11/03/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2019/11/03/面试复习笔记/</id>
    <published>2019-11-03T08:59:01.000Z</published>
    <updated>2020-01-07T15:32:32.774Z</updated>
    
    <content type="html"><![CDATA[<p>面试前知识点总结。</p><a id="more"></a><h2 id="一、前后端分离"><a href="#一、前后端分离" class="headerlink" title="一、前后端分离"></a>一、前后端分离</h2><p>当下有很多的基于语言的模板引擎：freemarker、beetl、thymeleaf 等，基于模板引擎的开发还是前后端存在耦合的。<br>核心思想是<strong>前端HTML页面通过AJAX调用后端的RESTFUL API接口并使用JSON数据进行交互</strong>。<br>1.未分离<br>前端请求—&gt;后端servlet处理—&gt;展示层jsp<br>后端还会采用模板引擎（FreeMarker、thymeleaf等）<br>这种方式需要前端先开发html页面，后端开发完接口后，再将html改为jsp文件集成接口。<br>耦合性太强，前端需要掌握各种模板引擎写法；jsp初次加载时需要翻译为servlet耗时较久的弊端。</p><p>2.半分离<br>前端开发页面—&gt;后端通过接口（Ajax）获取数据—&gt;前端采用Dom操作对页面进行数据绑定，最终是把页面渲染出来。<br>由于前端因为没有掌握controller层，前端需要跟后端讨论页面是要同步输出还是异步Json渲染，所以为半分离<br>  弊端：<br>      1）JS存在大量冗余，在业务复杂的情况下，页面的渲染部分的代码，非常复杂；<br>      2）在Json返回的数据量比较大的情况下，渲染的十分缓慢，会出现页面卡顿的情况；<br>      3）SEO（ Search Engine Optimization，即搜索引擎优化）非常不方便，由于搜索引擎的爬虫无法爬下JS异步渲染的数据，导致这样的页面，SEO会存在一定的问题；<br>      4）资源消耗严重，在业务复杂的情况下，一个页面可能要发起多次HTTP请求才能将页面渲染完毕。（特别是移动端）</p><p>3.全分离<br>前端负责view和controller层<br>后端只负责model层，业务处理与数据持久化等<br>前端Controller：node.js——适合运用在高并发、I/O密集、少量业务逻辑的场景<br>    浏览器请求—&gt;node.js—&gt;后端服务<br> 浏览器(webview)不再直接请求JSP的API，而是：<br>      1）浏览器请求服务器端的NodeJS；<br>      2）NodeJS再发起HTTP去请求JSP；<br>      3）JSP依然原样API输出JSON给NodeJS；<br>      4）NodeJS收到JSON后再渲染出HTML页面；<br>      5）NodeJS直接将HTML页面flush到浏览器；<br>      这样，浏览器得到的就是普通的HTML页面，而不用再发Ajax去请求服务器了。</p><h2 id="持久层框架：Jpa和Mybatis"><a href="#持久层框架：Jpa和Mybatis" class="headerlink" title="持久层框架：Jpa和Mybatis"></a>持久层框架：Jpa和Mybatis</h2><p>Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。<br>Spring Data Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架。<br>mybatis是一个半自动化的持久层框架。<br>传统公司：hibernate —&gt; Jpa —&gt; Spring Data Jpa<br>互联网公司：ibatis —&gt; mybatis<br>ref：<a href="https://blog.csdn.net/fuzhongmin05/article/details/81591072" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/81591072</a> </p><h2 id="Controller和-RestController"><a href="#Controller和-RestController" class="headerlink" title="@Controller和@RestController"></a>@Controller和@RestController</h2><p><strong>@RestController相当于@ResponseBody ＋ @Controller</strong><br>1.仅使用@RestController注解Controller，则Controller中的方法无法返回页面（InternalResourceViewResolver不起作用）<br>2.@Controller配合视图解析器InternalResourceViewResolver可以返回至return中的页面。<br>如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。</p><h2 id="JVM的垃圾回收"><a href="#JVM的垃圾回收" class="headerlink" title="JVM的垃圾回收"></a>JVM的垃圾回收</h2><p>1.回收算法：<br>（1）引用计数算法<br>    对象添加计数器，引用就加1，计数器为0时不再被使用到<br>    优：实现简单、判断效率高<br>    缺：无法解决循环引用问题<br>（2）可达性分析算法（java虚拟机使用）<br>    通过GC Roots的对象作为起始点，从这些节点向下搜索，搜索走过的路径称为引用链，当有对象到GC Roots没有引用链时，说明对象不可达。<br>    <img src="/2019/11/03/面试复习笔记/可达性分析算法.jpg" alt="可达性分析算法"><br>    优：精确严谨，可以分析出循环引用的情况<br>    缺：实现复杂，消耗大量时间，分析过程中需要保证引用关系不能发生变化，需要GC停顿，将挺短所有Java执行线程（“Stop The World”）<br>2.引用<br>（1）类型：<br>    强引用：Object object = new Object(); 强引用还存在，被引用的对象<br>    软引用：有用但非必须的对象。内存不够时（抛OOM Error之前），才会被垃圾回收。<br>    弱引用：非必须对象。垃圾回收器工作即会回收。<br>    虚引用：对象有虚引用不会影响其生存时间。<br>（2）筛选过程：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试前知识点总结。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="复习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>AOP之代理</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2019/10/10/AOP%E4%B9%8B%E4%BB%A3%E7%90%86/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2019/10/10/AOP之代理/</id>
    <published>2019-10-10T03:01:24.000Z</published>
    <updated>2019-11-03T08:42:08.035Z</updated>
    
    <content type="html"><![CDATA[<p>各种代理的学习</p><a id="more"></a><p>无代理：直接在方法内部修改</p><p>静态代理：新建一个类，调用原有类，在其前后增加补充操作</p><p>JDK动态代理：继承InvocationHandler，实现invoke方法，通过反射实现</p><p>CGLib动态代理：继承MethodInterceptor，实现intercept方法，提供方法级别的代理（可以代理没有任何接口的类）</p><p>原理区别：</p><p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p><p>而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p><p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP<br>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP </p><p>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p><p>JDK动态代理和CGLIB字节码生成的区别？<br> （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br> （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法<br>   因为是继承，所以该类或方法最好不要声明成final </p><p>ref：<a href="https://www.cnblogs.com/leifei/p/8263448.html" target="_blank" rel="noopener">https://www.cnblogs.com/leifei/p/8263448.html</a> [Spring的两种动态代理：Jdk和Cglib 的区别和实现]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各种代理的学习&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="代理" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>mysql踩坑记实</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2019/05/18/mysql%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%AE%9E/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2019/05/18/mysql踩坑记实/</id>
    <published>2019-05-18T10:40:36.000Z</published>
    <updated>2019-05-18T10:45:56.931Z</updated>
    
    <content type="html"><![CDATA[<p>各种问题记录</p><a id="more"></a><ol><li><p>项目启动报错：java.sql.SQLException: Unknown system variable ‘language’</p><p>mysql驱动版本过高，不兼容，需要换低版本的mysql</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各种问题记录&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mysql" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>驾照习得</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2019/04/27/%E9%A9%BE%E7%85%A7%E4%B9%A0%E5%BE%97/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2019/04/27/驾照习得/</id>
    <published>2019-04-27T15:14:28.000Z</published>
    <updated>2019-04-27T15:31:10.514Z</updated>
    
    <content type="html"><![CDATA[<p>驾考的艰辛历程（说多了都是lui啊 😭）</p><a id="more"></a><h2 id="一、报考"><a href="#一、报考" class="headerlink" title="一、报考"></a>一、报考</h2><p>纠结了n久，还是选择了传统驾校报名，互联网学车总是觉得有点不靠谱。小V目前还是学生，所以优惠价五千不到，还包括了补考学费，这在广州来说，已经是超超超超级便宜的了。<br>​<br>驾校报名之后，就是拍证件照(柯达就好，相馆老板还是帮你修图，关乎之后几年的驾照照片，所以还是要修的美美的比较好)。准备好这些资料后，就是等驾校的客服小姐姐帮忙录入车管所系统了，等待时间大概三五天左右。</p><h2 id="二、集中培训"><a href="#二、集中培训" class="headerlink" title="二、集中培训"></a>二、集中培训</h2><p>车管所审核资料通过后，会发短信来通知审核结果，另外，小v所在的驾校还会组织一次集中线下培训。线下培训是在驾驶理论培训基地统一上课，一个教室大概150人左右，培训一天。培训老师会把整个驾考流程、理论考试易错点以及实操考试注意事项等详细讲解。注意认真听，基本上都是重点，相当于把即将遇到的坑都给你讲清楚了。</p><h2 id="三、科目一"><a href="#三、科目一" class="headerlink" title="三、科目一"></a>三、科目一</h2><h4 id="1-刷题备考"><a href="#1-刷题备考" class="headerlink" title="1. 刷题备考"></a>1. 刷题备考</h4><p>下面是科目一的备考。注意有些驾校要求学生做至少三套试卷（手机APP的选择等下讲)，且分数必须在93分以上才给报名的，所以科目一的题可以在通知上理论课的时候就可以刷了。<br>​<br>先说APP的选择，个人觉得驾校宝典和驾校一点通都可以，功能都是一样的，但是驾校推荐使用驾校宝典，所以小v最终还是选择了它。<br>​<br>APP刷题时，切忌直接开始模拟，要先全部刷一遍所有题型，错题多看两遍，灵活使用APP的“收藏”功能。刷过全部题型之后，再把自己的错题多刷几遍(两遍至少)，之后才能开始做模拟套题。模拟套题要确保每次都有95分以上，那就可以大胆去考了。</p><h4 id="2-考试"><a href="#2-考试" class="headerlink" title="2.考试"></a>2.考试</h4><p>小v考试地方在化龙，驾校提前通知在某个地方等，教练开车把大家集体接过去考场。路程大概将近一个小时，一点开考，所以稍微晚一点，前面的人正好考完，不用排很久的队，去到就可以考。进考场时刷身份证，有空位置就可以坐下来考试，注意考试时候不能用手机，会视为作弊行为处理。<br>​<br>考试时是没人一台装有摄像头的电脑，大家用自己的身份证号登入，对准摄像头拍照记录。多人同时在线操作可能会导致系统提交比较卡顿，所以在做题时，需要用比平时刷题要多的时间和耐心。基本上一题选择好答案后，点击提交，需要等待至少3~5秒，这时候不要频繁点击，要耐心一点等待。曾有一起去考试的同学，因为系统卡顿，但是频繁点击提交，导致失误操作，险些不通过，所以这一点还是要注意一下。<br>​<br>答案卡上显示红色的是自己的错题，注意把握做题节奏。全部做完之后，会有弹窗显示本次考试是否通过。如果没有通过，则举手示意监考人员，在座位上等待5-10分钟，以后刷新重新做另一套套题。机试考试有两次机会，两次均不通过，则此次考试失败，通知客服人员重新安排补考。</p><h2 id="四、科目二"><a href="#四、科目二" class="headerlink" title="四、科目二"></a>四、科目二</h2><h3 id="1-上车"><a href="#1-上车" class="headerlink" title="1.上车"></a>1.上车</h3><p>检查车身，上车，关门，系安全带，松手刹。</p><h3 id="2-倒车入库"><a href="#2-倒车入库" class="headerlink" title="2.倒车入库"></a>2.倒车入库</h3><h4 id="左侧："><a href="#左侧：" class="headerlink" title="左侧："></a>左侧：</h4><p>（1）挂一档，轻放离合，前行至黄线刚过肩膀，快速向左打一圈加90°；</p><p>（2）维持方向盘不动，开至前车轮过黄线，踩刹车停车；</p><p>（3）挂倒挡，松刹车，看左后视镜，倒车；</p><p>（4）倒车至左后车轮在入库延长线30cm处，方向盘回90°；</p><p>（5）看右后视镜，车身与入库线角度小于10°，回正方向盘。</p><p>（6）继续缓慢倒车，看左后视镜，直到左后视镜把手挡住入库线，踩刹车停止。</p><h4 id="右侧："><a href="#右侧：" class="headerlink" title="右侧："></a>右侧：</h4><p>（1）挂一档，轻放离合前行，看左后视镜，看到左后车轮压在入库虚线上，向右快速打方向盘打死；</p><p>（2）前行至车身即将与边缘线平行时，打正方向盘，开至前车轮过黄线，踩刹车停车；</p><p>（3）挂倒挡，松刹车，看左后视镜，倒车；</p><p>（4）倒车至左后视镜把手挡住隔断线，向右快速打死方向盘；</p><p>（5）看右后视镜，继续倒车，当右后轮压到左起第三根黄线的一半时，回90°；</p><p>（6）换看左后视镜，当车身与黄线平行时，回正方向盘；</p><p>（7）继续缓慢倒车，看左后视镜，直到左后视镜把手挡住入库线，踩刹车停止。</p><h3 id="3-侧方停车"><a href="#3-侧方停车" class="headerlink" title="3.侧方停车"></a>3.侧方停车</h3><p>在主干道时，保持车身与右边缘黄线40cm，即引擎盖上“教练”圆圈标志再过10cm对准右侧黄线。</p><h4 id="进入停车位："><a href="#进入停车位：" class="headerlink" title="进入停车位："></a>进入停车位：</h4><p>（1）挂倒挡，松刹车，看左后视镜，倒车；</p><p>（2）倒车至左后视镜把手挡住隔断线，向右快速打方向盘1圈；</p><p>（3）看右后视镜，保证车轮不压黄线，进入后，换看左后视镜；</p><p>（4）看左后视镜倒车，直到看到停车位斜对角，立刻回正方向盘；</p><p>（5）继续看左后视镜，当左后车轮压黄色需线时，立刻向右打死方向盘；</p><p>（6）倒车至车头左线与右侧黄线相交，急踩刹车停止。</p><h4 id="开出停车位："><a href="#开出停车位：" class="headerlink" title="开出停车位："></a>开出停车位：</h4><p>（1）向下拨控制灯把手，<strong>开左转向灯</strong>，换1档，注意抓方向盘的手是叠加的；</p><p>（2）松刹车，轻放离合，前行至车头左线与外部右侧黄线相交，回正方向盘；</p><p>（3）缓慢前行，当车头中点与黄线相交，方向盘向右打1圈；</p><p>（4）当车身与黄线平行时，回正方向盘。</p><h3 id="4-曲线-直角行驶"><a href="#4-曲线-直角行驶" class="headerlink" title="4.曲线+直角行驶"></a>4.曲线+直角行驶</h3><p>车头拟四个点：<br>1.车头左侧1/4位置<br>2.车头左线缝<br>3.车头中间<br>4.车头左侧3/4位置</p><p>开车行驶至s形路口处，点刹，使车速慢下来，再将车身慢慢摆正，使驾驶位对准路口中间。<br>驶入曲线路口：</p><ol><li>缓慢前行，行驶到第一个拐点，当车头盖右菱角与黄色实线重合，向左打半圈，继续行驶；</li><li>当着行驶至路中间，与路边平行时，回正；</li><li>行驶到第二个拐点时，当车头盖左边缘点与实线重合，向右打半圈；</li><li>行驶至车头中间与实线重合，向右打90°；</li><li>转出第二个拐点后，当车头盖右边缘菱角与边缘先重合后，调整车头，使右菱角与实现压线行驶；</li><li>直行，直到车把手到达直角处，向右打方向盘，驶出直角。</li></ol><h3 id="5-斜坡定点停车"><a href="#5-斜坡定点停车" class="headerlink" title="5.斜坡定点停车"></a>5.斜坡定点停车</h3><p>踩死刹车、离合，松手刹，挂一档，慢松离合至车身抖动，松刹车，使车身沿边缘线形式。</p><p>听到指令停车，紧急踩刹车，拉手刹。</p><p>听到起步指令，按照上述动作缓慢平稳起步。</p><h2 id="五、科目三-科目四"><a href="#五、科目三-科目四" class="headerlink" title="五、科目三+科目四"></a>五、科目三+科目四</h2><p>科目二7月份考完，要等一个月才能报考科目三，然而约教练约不到，所以就去玩了。十月底才想起来决定完成这场考试。科目三与科目四可以联考，但是只有在下午一点之前考完科目三的同学才能在当天下午两点之后考可科目四。化龙考场比较偏僻，周围（尤其是科目四考试楼）没有便利店、餐馆，所以联考的同学做好中午叫外卖、自带午餐、考场门口买盒饭的准备。</p><p>科目三很简单，牢记各个点，就可以满分通过。科目四刷题即可，五分钟交卷走人~</p><ol><li>上车先检查灯光是否恢复。</li><li>起步时的五个步骤:左转向灯、喇叭、刹车离合挂一档、松手刹、左右看后视镜</li><li>靠边停车前打右转向灯，保持五秒后，再踩刹车停车。</li><li>在线内的时候就要打灯了，不要等起步了再打，那就迟了</li><li>夜间灯光考试：超车，过急弯、坡道、拱桥、人行横道打闪光灯；不良道路开远光；路边临时停车小灯；其余灯光都用近光灯。听到指令后五秒内做出动作，不得抢指令。</li></ol><p>有一点要注意，科目四笔试时：无信号灯路口用闪光。</p><p>下图是科目三练习道路：</p><p><img src="/2019/04/27/驾照习得/练习路段.jpg" alt="练习道路"></p><p>科目三考试路段（展贸东路）</p><p><img src="/2019/04/27/驾照习得/考试路段.jpg" alt="考试路段"></p><h2 id="考试后第三天"><a href="#考试后第三天" class="headerlink" title="考试后第三天"></a>考试后第三天</h2><p><img src="/2019/04/27/驾照习得/热乎的.jpg" alt="热乎的"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;驾考的艰辛历程（说多了都是lui啊 😭）&lt;/p&gt;
    
    </summary>
    
      <category term="手记" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E6%89%8B%E8%AE%B0/"/>
    
    
      <category term="手记" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E6%89%8B%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用小结</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2019/04/27/Git%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2019/04/27/Git使用小结/</id>
    <published>2019-04-27T10:30:06.000Z</published>
    <updated>2019-08-11T09:52:51.051Z</updated>
    
    <content type="html"><![CDATA[<p>git使用以及常用指令。</p><a id="more"></a><h2 id="Git-使用小结"><a href="#Git-使用小结" class="headerlink" title="Git 使用小结"></a>Git 使用小结</h2><h4 id="常用指令记录"><a href="#常用指令记录" class="headerlink" title="常用指令记录"></a>常用指令记录</h4><p>1.git 取消文件 add：git reset HEAD + 文件名  （不加文件名，表示全部的add都取消）；</p><p>2.修改最近一次提交的注释信息：git commit –amend</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git使用以及常用指令。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>《心做し》译音歌词</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2018/06/13/%E3%80%8A%E5%BF%83%E5%81%9A%E3%81%97%E3%80%8B%E8%AF%91%E9%9F%B3%E6%AD%8C%E8%AF%8D/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2018/06/13/《心做し》译音歌词/</id>
    <published>2018-06-13T14:34:18.000Z</published>
    <updated>2018-06-14T11:15:47.928Z</updated>
    
    <content type="html"><![CDATA[<p>双笙小姐姐唱的《心做し》真的好好听，这让不会日语的我陷入了囧境😭……</p><a id="more"></a><h2 id="《心做し》译音歌词"><a href="#《心做し》译音歌词" class="headerlink" title="《心做し》译音歌词"></a>《心做し》译音歌词</h2><p>A1段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乃莫西莫 四百呆那盖四 呆拉来大拉<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哇拉呆 一给喽勾豆嘎 拉古尼闹诺莫<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;马大闹买嘎一大 勾那喽勾来<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫纳尼莫 一哇那一呆右 </p><p>A2段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乃莫西莫 四百呆来嗖来拉乃 嘎那拉<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那个那一呆 一给喽勾豆莫 拉古尼纳诺莫<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;呆莫所恩那过多 白K那嘎哇<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;莫纳尼莫 云塞那一呆右</p><p>B1段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K米尼 豆类大盖及盖 走音呆莫<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;柏苦诺 心音坐哇Hi豆 嗖大盖</p><p>C1段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hi豆一右 Hi豆一右 莫力嗖勾 喽勾拉乃欧<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;勾哇西呆 一K塞一呆 四给那右 欧尼西呆右<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;洒看呆 莫嘎一呆 马不大欧 阿拉西太莫<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;马乐K米哇 柏扩农多多<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大一西买 呆阿乃塞来 莫忆右</p><p>A3段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乃莫西柏 柏扩农来大嘎 卡那欧那嘎<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K米豆 欧乃记莫农嘎 后西因大<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;呆莫莫 苦尼哇送 塞西那嘎大<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加塞乃呆 柏扩尼K呆右</p><p>B2段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K米尼 豆类大盖阿一 洒来呆莫<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;柏苦诺 心音坐哇Hi豆 嗖大盖</p><p>C2段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;压买呆右 压买呆右 压洒西勾 西那一呆右<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;豆西呆莫 莫古尼哇 米嘎一那 呆盖那一右<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一呆一右 一呆一右 勾豆八 哎右西耶呆右<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;勾ong那农 西大那一右 一到尼尼 西那一呆</p><p>C3段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hi豆一右 Hi豆一右 莫力嗖勾 喽勾拉来欧<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;勾哇西呆 一K塞一呆 嗖给那右 欧尼西呆右<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;洒看呆 莫嘎一呆 马不嘎欧 阿来西太莫<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;马乐K米哇 柏扩农多多<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大一西买 呆阿乃塞来 莫忆右</p><p>A4段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;乃莫西柏 柏扩尼勾勾喽 嘎阿农那拉<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;豆压呆 嗖呆欧米子盖 来八因农<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嗖勾西后后哎恩 乃K米豆右<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嗖来八乃 勾勾尼 阿力右</p><h2 id="《心做し》中文歌词"><a href="#《心做し》中文歌词" class="headerlink" title="《心做し》中文歌词"></a>《心做し》中文歌词</h2><p>A1段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;吶若能 将一切 都彻底舍弃<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;笑着 活下去 就会变得轻松吗<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可我的心还会痛<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以 求你什么都别说</p><p>A2段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;吶若能 将一切 都彻底遗忘<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无需 泪水的生活 也会变得轻松吗<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可是我做不到<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以 求你什么都别给我看</p><p>B1段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再怎么接近你<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的 心脏仅此一颗</p><p>C1段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好残忍 好残忍 你干脆就这么<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;撕碎我的身体吧 随你喜欢就好了<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;呐喊过 挣扎过 再怎么哭肿双眼<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你却依然 抱紧我不放手 真的已经够了</p><p>A3段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 我的心愿 可以实现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只求 能和你有共同点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可是我身上并不存在<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么至少来我这里吧</p><p>B2段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再怎么被你爱着<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我的 心脏仅此一颗</p><p>C2段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;停止吧 停止吧 别再对我温柔了<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何我就是 理解不了啊<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好痛 真的好痛 亲口告诉我吧<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种事 我不懂啊 别留我 一个人</p><p>C3段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好残忍 好残忍 你干脆就这么<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;撕碎我的身体吧 随你喜欢就好了<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;呐喊过 挣扎过 再怎么哭肿双眼<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你却依然 抱紧我不放手 真的已经够了</p><p>A4段:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;吶如果 我有心 我该怎么做<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;才能找到它<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你微微笑着说道<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那个啊 就在这里唷</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;双笙小姐姐唱的《心做し》真的好好听，这让不会日语的我陷入了囧境😭……&lt;/p&gt;
    
    </summary>
    
      <category term="手记" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E6%89%8B%E8%AE%B0/"/>
    
    
      <category term="词" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>区块链浅谈</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2018/06/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%B5%85%E8%B0%88/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2018/06/03/区块链浅谈/</id>
    <published>2018-06-03T12:00:30.000Z</published>
    <updated>2018-06-13T15:08:07.851Z</updated>
    
    <content type="html"><![CDATA[<p>想了解一下区块链是干嘛的，以及其中包含的技术栈^^</p><a id="more"></a><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><h3 id="工作理念"><a href="#工作理念" class="headerlink" title="工作理念"></a>工作理念</h3><p>大家共同参与记账，通过一种规则不断选出账务打包者，其他节点接收验证，并且每个用户都有一对密钥表示自己，通过脚本系统的功能实现在公共网络中定向发送有价值的数据。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>A用户需要给B用户发送数据。数据由A发送出去后，会被打包进区块，然后广播出去给所有节点确认，确认没有问题之后就写入到各自的本地区块链账本中，当网络中的大多数节点都确认写入之后，该发送数据的过程则算结束。</p><p>整个区块链网络就是大家维护一份公共账本，这个公共账本是一个逻辑概念，各自维护自己的账本，但要保持账目一致。</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>基本技术组合：共识机制、密码算法、网络路由、脚本系统、区块链账本。</p><h4 id="1-区块链账本"><a href="#1-区块链账本" class="headerlink" title="1.区块链账本"></a>1.区块链账本</h4><p>区块中主要包括交易事务数据以及区块摘要信息。</p><p>一个区块是由区块头和区块交易事务组成，二者通过“梅克尔根”相关联；区块之间则是以“前一个区块头哈希”串联起来。（这就造成了<strong>区块链之间不可从中间破坏</strong>的特点，如果要删除或新增，则后面的所有区块都更改；其他节点不会接受被窜改的数据，因为与本地数据不匹配，这造成了<strong>区块不可篡改</strong>的特点）</p><p>####2.共识机制</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想了解一下区块链是干嘛的，以及其中包含的技术栈^^&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="区块链" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句小记</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2018/05/14/sql%E8%AF%AD%E5%8F%A5%E5%B0%8F%E8%AE%B0/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2018/05/14/sql语句小记/</id>
    <published>2018-05-14T10:42:23.000Z</published>
    <updated>2018-05-25T05:21:15.244Z</updated>
    
    <content type="html"><![CDATA[<p>记录常用SQL语句。</p><a id="more"></a><h5 id="1-为表中字段添加唯一约束"><a href="#1-为表中字段添加唯一约束" class="headerlink" title="1.为表中字段添加唯一约束"></a>1.为表中字段添加唯一约束</h5><p>alter table TABLE_NAME add unique key (COLUMN_NAME); </p><h5 id="2-为表中字段添加联合唯一约束"><a href="#2-为表中字段添加联合唯一约束" class="headerlink" title="2.为表中字段添加联合唯一约束"></a>2.为表中字段添加联合唯一约束</h5><p>alter table TABLE_NAME add unique key (COLUMN_NAME_1, COLUMN_NAME_2) ;</p><h5 id="3-可变长度类型的字段设置索引，需要限制长度（前n个）"><a href="#3-可变长度类型的字段设置索引，需要限制长度（前n个）" class="headerlink" title="3.可变长度类型的字段设置索引，需要限制长度（前n个）"></a>3.可变长度类型的字段设置索引，需要限制长度（前n个）</h5><p>alter table TABLE_NAME add unique key (COLUMN_NAME_1, COLUMN_NAME_2(255))；</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录常用SQL语句。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="SQL" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>linux指令小结</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2018/05/14/linux%E6%8C%87%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2018/05/14/linux指令小结/</id>
    <published>2018-05-14T10:30:06.000Z</published>
    <updated>2018-05-25T05:25:08.295Z</updated>
    
    <content type="html"><![CDATA[<p>记录linux学习。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录linux学习。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>突击webmagic</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2018/03/27/%E7%AA%81%E5%87%BBwebmagic/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2018/03/27/突击webmagic/</id>
    <published>2018-03-27T02:45:27.000Z</published>
    <updated>2018-04-01T03:24:44.966Z</updated>
    
    <content type="html"><![CDATA[<p>Java爬虫框架<br><a id="more"></a></p><h1 id="主要包构成"><a href="#主要包构成" class="headerlink" title="主要包构成"></a>主要包构成</h1><h2 id="webmagic-core"><a href="#webmagic-core" class="headerlink" title="webmagic-core"></a>webmagic-core</h2><p>核心包，包含爬虫基本模块和基本抽取器。  </p><h2 id="webmagic-extension"><a href="#webmagic-extension" class="headerlink" title="webmagic-extension"></a>webmagic-extension</h2><p>拓展模块，提供工具，包括注解格式定义爬虫、json、分布式支持。<br>注解方式：基于POJO增加注释</p><h4 id="AfterExtractor"><a href="#AfterExtractor" class="headerlink" title="AfterExtractor"></a>AfterExtractor</h4><p>该接口是对注解方式抽取能力不足的补充。<br>使用注解方式填充完字段后调用<strong>afterProcess()</strong>方法，在这个方法中可以直接访问已抽取的字段、补充需要抽取的字段，甚至做一些简单的输出和持久化操作(并不是很建议这么做)。</p><h4 id="OOSpider"><a href="#OOSpider" class="headerlink" title="OOSpider"></a>OOSpider</h4><p>OOSpider是注解式爬虫的入口。<br>这里调用<strong>create()</strong>方法将model类加入到爬虫的抽取中，这里是可以传入多个类的。</p><h4 id="PageModelPipeline"><a href="#PageModelPipeline" class="headerlink" title="PageModelPipeline"></a>PageModelPipeline</h4><p>定义该接口来选择结果的输出方式。<br>PageModelPipeline目前包括ConsolePageModelPipeline、JsonFilePageModelPipeline、FilePageModelPipeline三个实现。</p><p><br><br><br><br><br><br><br></p><h1 id="拓展包"><a href="#拓展包" class="headerlink" title="拓展包"></a>拓展包</h1><h2 id="webmagic-saxon"><a href="#webmagic-saxon" class="headerlink" title="webmagic-saxon"></a>webmagic-saxon</h2><p>webmagic与saxon结合，saxon是xpath和xslt的解析工具。</p><h2 id="webmagic-selenium"><a href="#webmagic-selenium" class="headerlink" title="webmagic-selenium"></a>webmagic-selenium</h2><p>webmagic与selenium结合进行动态页面抓取，selenium可迷你浏览器进行页面渲染。</p><p><br><br><br><br><br><br><br></p><p>#模块划分#</p><p><div style="width:50%;align:left"><br><img src="http://code4craft.github.io/images/posts/webmagic.png"><br></div>  </p><h2 id="DownLoader"><a href="#DownLoader" class="headerlink" title="DownLoader"></a>DownLoader</h2><p>页面下载</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="HttpClientDownloader"><a href="#HttpClientDownloader" class="headerlink" title="HttpClientDownloader"></a>HttpClientDownloader</h4><p>集成Apache HttpClient（Java http下载器，支持自定义http头（user-agent,cookie）、自动redirect、连接复用、cookie保留、设置代理等）</p><h4 id="SeleniumDownloader"><a href="#SeleniumDownloader" class="headerlink" title="SeleniumDownloader"></a>SeleniumDownloader</h4><p>实现动态页面抓取</p><h2 id="PageProcessor-链接提取和页面分析"><a href="#PageProcessor-链接提取和页面分析" class="headerlink" title="PageProcessor - 链接提取和页面分析"></a>PageProcessor - 链接提取和页面分析</h2><p>实现PageProcessor可以<strong>自定义</strong>爬虫逻辑。  </p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="public-Page-download-Request-request-Task-task"><a href="#public-Page-download-Request-request-Task-task" class="headerlink" title="public Page download(Request request, Task task)"></a>public Page download(Request request, Task task)</h4><p>task是包装了任务对应的Site信息的抽象接口。</p><h4 id="public-void-setThread-int-thread"><a href="#public-void-setThread-int-thread" class="headerlink" title="public void setThread(int thread)"></a>public void setThread(int thread)</h4><p>Downloader涉及连接池等。</p><h3 id="核心方法-1"><a href="#核心方法-1" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="public-void-process-Page-page"><a href="#public-void-process-Page-page" class="headerlink" title="public void process(Page page)"></a>public void process(Page page)</h4><table><thead><tr><th style="text-align:right">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:right">page.addTargetRequests()</td><td style="text-align:left">增加要抓取的URL</td></tr><tr><td style="text-align:right">page.putField()</td><td style="text-align:left">保存抽取结果</td></tr><tr><td style="text-align:right">page.getHtml().xpath()</td><td style="text-align:left">按照某个规则对结果进行抽取</td></tr><tr><td style="text-align:right">toString()</td><td style="text-align:left">返回单个String</td></tr><tr><td style="text-align:right">all()</td><td style="text-align:left">返回String列表</td></tr></tbody></table><h4 id="public-Site-getSite"><a href="#public-Site-getSite" class="headerlink" title="public Site getSite()"></a>public Site getSite()</h4><p>Site对象定义了爬虫的域名、起始地址、抓取间隔、编码等信息。</p><h4 id="Selector-简化页面抽取"><a href="#Selector-简化页面抽取" class="headerlink" title="Selector 简化页面抽取"></a>Selector 简化页面抽取</h4><p>整合了cssSelector、xpath、正则表达式<br>SmartContentSelector 对于页面正文的自动抽取的类。<br>Xsoup对xpath的语法进行拓展，支持自定义函数（在xpath末尾加上/name-of-function<br>()）  </p><table> <tr> <td width="100">函数</td> <td>说明</td> </tr> <tr> <td width="100">text(n)</td> <td>第n个文本节点(0表示取所有)</td> </tr> <tr> <td width="100">allText()</td> <td>包括子节点的所有文本</td> </tr>  <tr> <td width="100">tidyText()</td> <td>包括子节点的所有文本，并进行智能换行</td> </tr> <tr> <td width="100">html()</td> <td>内部html(不包括当前标签本身)</td> </tr> <tr> <td width="100">outerHtml()</td> <td>外部html(包括当前标签本身)</td> </tr> <tr> <td width="100">regex(@attr,expr,group)</td> <td>正则表达式，@attr是抽取的属性(可省略)，expr是表达式内容，group为捕获组(可省略，默认为0)</td> </tr> </table>  <h2 id="Spider-爬虫调度框架"><a href="#Spider-爬虫调度框架" class="headerlink" title="Spider - 爬虫调度框架"></a>Spider - 爬虫调度框架</h2><p>爬虫入口（核心调度） </p><pre> Spider.create(blogProcessor)      .scheduler(new FileCacheQueueScheduler("/data/temp/webmagic/cache/"))      .pipeline(new FilePipeline())      .thread(10).run();  `</pre><p>核心处理流程</p><pre>private void processRequest(Request request) {        Page page = downloader.download(request, this);        if (page == null) {            sleep(site.getSleepTime());            return;        }        pageProcessor.process(page);        addRequest(page);        for (Pipeline pipeline : pipelines) {            pipeline.process(page, this);        }        sleep(site.getSleepTime());    }</pre><h2 id="Scheduler-URL管理"><a href="#Scheduler-URL管理" class="headerlink" title="Scheduler - URL管理"></a>Scheduler - URL管理</h2><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><h4 id="public-void-push-Request-request-Task-task"><a href="#public-void-push-Request-request-Task-task" class="headerlink" title="public void push(Request request,Task task)"></a>public void push(Request request,Task task)</h4><p>将待抓取的URL加入到Scheduler里面。request是对URL的一个封装，包括优先级、一个存储数据的Map</p><h4 id="public-Request-poll-Task-task"><a href="#public-Request-poll-Task-task" class="headerlink" title="public Request poll(Task task)"></a>public Request poll(Task task)</h4><p>从Scheduler中取出一条请求。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><h4 id="QueueScheduler"><a href="#QueueScheduler" class="headerlink" title="QueueScheduler"></a>QueueScheduler</h4><h4 id="FileCacheQueueScheduler"><a href="#FileCacheQueueScheduler" class="headerlink" title="FileCacheQueueScheduler"></a>FileCacheQueueScheduler</h4><h4 id="RedisScheduler"><a href="#RedisScheduler" class="headerlink" title="RedisScheduler"></a>RedisScheduler</h4><h2 id="Pipeline-离线分析和持久化"><a href="#Pipeline-离线分析和持久化" class="headerlink" title="Pipeline - 离线分析和持久化"></a>Pipeline - 离线分析和持久化</h2><p>结果输出和持久化。  </p><h3 id="主要方法-1"><a href="#主要方法-1" class="headerlink" title="主要方法"></a>主要方法</h3><p>public void process(ResultItems resultItems,Task task)<br>ResultItems是包含抽取结果的对象，通过ResultItems.get(key)可获取结果。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><h4 id="ConsolePipeline-输出到控制台。"><a href="#ConsolePipeline-输出到控制台。" class="headerlink" title="ConsolePipeline 输出到控制台。"></a>ConsolePipeline 输出到控制台。</h4><h4 id="FilePipeline"><a href="#FilePipeline" class="headerlink" title="FilePipeline"></a>FilePipeline</h4><h4 id="JsonFilePipeline"><a href="#JsonFilePipeline" class="headerlink" title="JsonFilePipeline"></a>JsonFilePipeline</h4><h3 id="webmagic目前还不支持持久化到数据库。可以结合JFinal"><a href="#webmagic目前还不支持持久化到数据库。可以结合JFinal" class="headerlink" title="webmagic目前还不支持持久化到数据库。可以结合JFinal"></a>webmagic目前还不支持持久化到数据库。可以结合JFinal</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java爬虫框架&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="爬虫" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="webmagic" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/webmagic/"/>
    
  </entry>
  
  <entry>
    <title>maupassant主题设置gitment</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2018/03/25/maupassant%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AEgitment/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2018/03/25/maupassant主题设置gitment/</id>
    <published>2018-03-25T05:25:13.000Z</published>
    <updated>2018-03-27T03:35:38.347Z</updated>
    
    <content type="html"><![CDATA[<p>maupassant主题设置gitment踩坑记录。<br><a id="more"></a><br>1.在主题的配置文件_config.yml中更改配置如下：</p><div style="width:70%;align:left"><br><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1521966153467&di=17a022292609fafdfa8aff705fb38d39&imgtype=jpg&src=http%3A%2F%2Fh.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F500fd9f9d72a605932b1f9162434349b033bba1c.jpg"><br></div><br>* 注意大小写，写错会报“Error: Not Found”）<br><br>2.修改文件Blog\themes\maupassant\layout_partial\comments.pug，设置样式内容：<br><div style="width:90%;align:left"><br><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1521966602824&di=23bc17b1564c7b55592c0d23aef66241&imgtype=jpg&src=http%3A%2F%2Ff.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2Fac6eddc451da81cba4a986c15e66d0160924316a.jpg"><br></div><p><pre><code><br>link(rel=’stylesheet’, href=’<a href="https://imsun.github.io/gitment/style/default.css&#39;" target="_blank" rel="noopener">https://imsun.github.io/gitment/style/default.css&#39;</a>)<br>script(src=’<a href="https://imsun.github.io/gitment/dist/gitment.browser.js&#39;" target="_blank" rel="noopener">https://imsun.github.io/gitment/dist/gitment.browser.js&#39;</a>)</code><br></pre><br>将划线部分复制粘贴，并补充将id值改为page.date（如不加，则默认传入文章url，超过50个字符报错“Error：validation failed”）</p><p>3.在每篇的开头部分补充  comments: true  </p><div style="width:30%;align:left"><br><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1521967111606&di=0dede719fa62743754e6e7eeaf6c5777&imgtype=jpg&src=http%3A%2F%2Fa.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F8718367adab44aedfe61b8e8bf1c8701a18bfb8b.jpg"><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;maupassant主题设置gitment踩坑记录。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="hexo" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/hexo/"/>
    
      <category term="踩坑" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="gitment" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/gitment/"/>
    
  </entry>
  
  <entry>
    <title>hexo更换主题，本地可以，上传git则不生效</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2018/03/23/hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%8F%AF%E4%BB%A5%EF%BC%8C%E4%B8%8A%E4%BC%A0git%E5%88%99%E4%B8%8D%E7%94%9F%E6%95%88/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2018/03/23/hexo更换主题，本地可以，上传git则不生效/</id>
    <published>2018-03-23T13:40:54.000Z</published>
    <updated>2018-03-27T02:58:22.234Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Q</strong>:运行原主题landscape正常，更换主题后，hexo g生成文件，hexo s使其在本地运行，运行正常，hexo d上传到github，访问出现空白无内容以及乱码。<br><a id="more"></a><br><strong>A</strong>:查询了一些资料,得到这可能是hexo的缓存的问题，即根目录的db.json文件。所以在发布网站之前，先用hexo clean清除缓存，然后再部署网站。  </p><p>清除缓存的方法：  </p><ol><li>执行命令：hexo clean  </li><li>然后可以生成静态博客并在本地预览：hexo g ; hexo s</li></ol><p><strong>另</strong>：在多次上传后，同一浏览器存在缓存，故导致改变不能立刻显示，利用Ctrl+F5强制刷新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;:运行原主题landscape正常，更换主题后，hexo g生成文件，hexo s使其在本地运行，运行正常，hexo d上传到github，访问出现空白无内容以及乱码。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="hexo" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/hexo/"/>
    
      <category term="theme" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/theme/"/>
    
      <category term="踩坑" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>用chkdsk删除损坏文件</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2018/03/23/%E7%94%A8chkdsk%E5%88%A0%E9%99%A4%E6%8D%9F%E5%9D%8F%E6%96%87%E4%BB%B6/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2018/03/23/用chkdsk删除损坏文件/</id>
    <published>2018-03-23T11:18:45.000Z</published>
    <updated>2018-03-27T03:39:37.470Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Q</strong>:系统盘文件夹已损坏无法直接删除，提示需要调用系统命令chkdsk删除该文件。<br><a id="more"></a><br><strong>A</strong>：cmd运行“chkdsk E: /f”扫描指定盘（E盘），自动检查之后进行删除，自动关闭。<br>系统会检查出已损坏文件，并删除，健康文件依旧保留。  </p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80%20&amp;size=b10000_10000&amp;sec=1521814233947&amp;di=3e111ac9cd31867c4a6b504398d78ec1&amp;imgtype=jpg&amp;src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F7af40ad162d9f2d31b76dfe6a5ec8a136327cc50.jpg" alt="chkdsk处理坏文件" title="chkdsk处理坏文件"></p><p><div id="container"></div></p><p><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"></p><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({  id: '<%= page.date %>'  owner: 'Vvvvvvvvvvvvvvvvicky',  repo: 'comment.github.io',  oauth: {    client_id: 'da11ae3e133507a54c29',    client_secret: '5ee4f2c6cf5943d8437c673222e48f249bee5cf9',  },})gitment.render('container')</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;:系统盘文件夹已损坏无法直接删除，提示需要调用系统命令chkdsk删除该文件。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="踩坑" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="踩坑" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="windows" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>VSTS笔记</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2017/12/26/VSTS%E7%AC%94%E8%AE%B0/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2017/12/26/VSTS笔记/</id>
    <published>2017-12-25T16:12:52.000Z</published>
    <updated>2018-03-27T03:38:34.736Z</updated>
    
    <content type="html"><![CDATA[<p>搭建TFS之后，再度体验线上版本的VSTS，记录学习过程<br><a id="more"></a></p><h1 id="VSTS笔记-nbsp-nbsp-nbsp-Day-1"><a href="#VSTS笔记-nbsp-nbsp-nbsp-Day-1" class="headerlink" title="VSTS笔记&nbsp;&nbsp;&nbsp;Day 1"></a>VSTS笔记&nbsp;&nbsp;&nbsp;Day 1</h1><p>Epic<br>&nbsp;&nbsp;Feature<br>&nbsp;&nbsp;&nbsp;&nbsp;Story<br>&nbsp;&nbsp;&nbsp;&nbsp;Story<br>&nbsp;&nbsp;Feature<br>&nbsp;&nbsp;&nbsp;&nbsp;Story<br>&nbsp;&nbsp;&nbsp;&nbsp;Story  </p><p>以上为三者的包含关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建TFS之后，再度体验线上版本的VSTS，记录学习过程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="VSTS" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/VSTS/"/>
    
  </entry>
  
  <entry>
    <title>EntityManager相关</title>
    <link href="https://vvvvvvvvvvvvvvvvicky.github.io/2017/10/05/%E7%AE%80%E4%BB%8BEntityManager/"/>
    <id>https://vvvvvvvvvvvvvvvvicky.github.io/2017/10/05/简介EntityManager/</id>
    <published>2017-10-05T15:37:54.000Z</published>
    <updated>2018-03-27T03:38:53.345Z</updated>
    
    <content type="html"><![CDATA[<p>EntityManager的含义及用法<br><a id="more"></a></p><h3 id="EntityManager介绍"><a href="#EntityManager介绍" class="headerlink" title="EntityManager介绍"></a>EntityManager介绍</h3><p>EntityManager是JPA操作基础，获取到EntityManager实例后，才能通过JPA对数据库进行操作，类似于Connection实例和JDBC的关系。</p><h3 id="什么是JPA"><a href="#什么是JPA" class="headerlink" title="什么是JPA"></a>什么是JPA</h3><p><strong>JPA —— Java Persistence API  Java持久化API</strong><br>定义了 对象-关系映射+实体对象持久化标准接口<br>JPA在持久化上下文中维护实体生命周期：<br>&nbsp;&nbsp;1. ORM元数据（支持annotation和xml）<br>&nbsp;&nbsp;2. 实体CRUD操作<br>&nbsp;&nbsp;2. 查询JPQL  </p><h3 id="实体的生命周期"><a href="#实体的生命周期" class="headerlink" title="实体的生命周期"></a>实体的生命周期</h3><ol><li>new ——新创建的实体对象，未分配主键值  </li><li>managed ——被EntityManager管理，处于Persistence Context  </li><li>detached ——处于Application Domain，在Persistance Context之外  </li><li>removed ——对象被删除  </li></ol><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ol><li>persist ——持久化（将新建或已删除的实体变为managed状态，存库）  </li><li>remove ——删除实体  </li><li>merge ——游离实体变为managed，存库  <div style="width:60%;align:center"><br><img src="https://timgsa.baidu.com/timg?image&quality=80%20&size=b10000_10000&sec=1507292305525&di=5c933128fa51ab422023b3310969573d&imgtype=jpg&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2Fa9d3fd1f4134970a2c76ab5b9ecad1c8a7865db8.jpg"><br></div>  </li></ol><h3 id="实体关系映射-ORM"><a href="#实体关系映射-ORM" class="headerlink" title="实体关系映射 ORM"></a>实体关系映射 ORM</h3><h4 id="基本映射"><a href="#基本映射" class="headerlink" title="基本映射"></a>基本映射</h4><table><thead><tr><th style="text-align:left">对象</th><th style="text-align:left">数据库</th><th style="text-align:left">annotation</th><th style="text-align:left">可选annotation</th></tr></thead><tbody><tr><td style="text-align:left">Class</td><td style="text-align:left">Table</td><td style="text-align:left">@Entity</td><td style="text-align:left">@Table(name=”tableName”)</td></tr><tr><td style="text-align:left">property</td><td style="text-align:left">colum</td><td style="text-align:left">@Id</td><td style="text-align:left">@GeneratedValue</td></tr><tr><td style="text-align:left">property</td><td style="text-align:left">primary key</td><td style="text-align:left">@Entity</td><td style="text-align:left">@Table(name=”tableName”)</td></tr><tr><td style="text-align:left">property</td><td style="text-align:left">NONE</td><td style="text-align:left">@Transient</td></tr></tbody></table><h4 id="ID生成策略"><a href="#ID生成策略" class="headerlink" title="ID生成策略"></a>ID生成策略</h4><ol><li>GeneratorType.AUTO JPA自动生成</li><li>GenerationType.IDENTITY 数据库自增长</li><li>GenerationType.SEQUENCE 数据库序列号</li><li>GenerationType.TABLE 数据库表记录ID的增长（需定义一个TableGenarator）</li></ol><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><table><thead><tr><th style="text-align:left">关系类型</th><th style="text-align:left">Owning-Side</th><th style="text-align:left">Inverse-Side</th></tr></thead><tbody><tr><td style="text-align:left">one-to-one</td><td style="text-align:left">@OneToOne</td><td style="text-align:left">@OneToOne(mappedBy=”othersideName”)</td></tr><tr><td style="text-align:left">one-to-many / @ManyToOne</td><td style="text-align:left">colum</td><td style="text-align:left">@OneToMany(mappedBy=”xxx”)</td></tr><tr><td style="text-align:left">many-to-many</td><td style="text-align:left">@ManyToMany</td><td style="text-align:left">@ManyToMany(mappedBy =”xxx”)</td></tr></tbody></table><h3 id="查询语言"><a href="#查询语言" class="headerlink" title="查询语言"></a>查询语言</h3><ol><li>根据主键查询，EntityManager的find方法：T find(Class entityClass, Object primaryKey)  </li><li>使用JPQL查询语言（完全面向对象，类似hibernate HQL），使用EntityManager的createQuery方法：Query createQuery(String qlString)  <h5 id="EntityManager的各个方法"><a href="#EntityManager的各个方法" class="headerlink" title="EntityManager的各个方法"></a>EntityManager的各个方法</h5><img src="https://timgsa.baidu.com/timg?image&amp;quality=80%20&amp;size=b10000_10000&amp;sec=1507467896237&amp;di=7ce1661ed3e030471ba1624402867d55&amp;imgtype=jpg&amp;src=http%3A%2F%2Fb.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F91529822720e0cf30e1627830146f21fbf09aae1.jpg" alt="EntityManager方法"></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EntityManager的含义及用法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://vvvvvvvvvvvvvvvvicky.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
